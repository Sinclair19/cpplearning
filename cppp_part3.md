PART 3 类设计者的工具

# 13 拷贝控制
一个类通过定义五种特殊成员函数来控制操作
1. 拷贝构造函数
2. 拷贝赋值运算符
3. 自动构造函数
4. 移动赋值运算符
5. 析构函数

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数
```cpp
class Foo{
    public:
        Foo();
        Foo(const Foo&);
}
```
拷贝构造函数的第一个参数必须是一个引用类型
- 合成拷贝构造函数
    - 对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象
    - 一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中
        - 每个成员的类型决定了它如何拷贝
- 拷贝初始化
    - 在以下情况下也会发生
        - 将一个对象作为实参传递给一个非引用类型的形参
        - 从一个返回类型为非引用类型的函数返回一个对象
        - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
    - 使用标准库容器或是调用其 insert 或 push 成员时，容器会对其匀速进行拷贝初始化
    - 用 emplace 的成员创建的元素都进行直接初始化
- 参数和返回值
    - 拷贝构造函数被用来初始化非引用类类型参数
- 拷贝初始化的限制
- 编译器可以绕过拷贝构造函数
    - 在初始化工程中，编译器可以但不是必须跳过/移动构造函数，直接创建对象

### 13.1.2 拷贝赋值运算符
- 重载赋值运算符
    - 本质为函数，名字由 operator 关键字后接表示要定义的运算符的符号组成
    - 拷贝赋值运算符接受一个与其所在类相同类型的参数
    - 赋值运算符通常应该返回一个指向其左侧运算对象的引用
- 合成拷贝赋值运算符
    - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

### 13.1.3 析构函数
- 构造函数初始化对象的非 static 数据成员，还可能做一些其他工作
- 析构函数释放对象使用的资源，并销毁对象的非 static 数据成员
- 对一个给定类，只会有一个析构函数
- 析构函数完成什么工作
    - 首先执行函数体，然后销毁成员，成员按初始化的逆序销毁
    - 对象最后一次使用之后，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，西沟部分是隐式的，成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁呢之类型成员什么也不需要做
    - 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象
- 什么时候会调用析构函数
    - 无论何时一个对象被销毁，就会自动调用其析构函数
        - 变量在离开其作用域时被销毁
        - 当一个对象被销毁时，其成员被销毁
        - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
        - 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁
        - 对于临时对象，当创建它的完整表达式结束时被销毁
    - 当指向一个对象的引用或指针离开作用域时，析构函数不会执行
- 合成析构函数
    - 可以用来阻止该类型的对象被销毁
    - 析构函数是作为成员销毁步骤之外的另一部分而进行的


### 13.1.4 三/五法则
- 需要析构函数的类也需要拷贝和赋值操作
    - 通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显，如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
- 需要拷贝操作的类也需要赋值操作，反之亦然

### 13.1.5 使用 =default
可以通过将拷贝成员定义为 =default 来显式的要求编译器生成合成的版本
- 只能对具有合成版本的成员函数使用 = default

### 13.1.6 阻止拷贝
- 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地
- 定义删除的函数
    - 可以通过将拷贝构造函数和赋值运算符定义为删除的函数来阻止拷贝
    - 虽然声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上 =delete 来指出我们希望它定义为删除的
    - = default 必须出现在函数第一次声明的时候
    - 可以对任何函数指定 =delete
- 析构函数不能是删除的成员
    - 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针
- 合成的拷贝控制成员可能是删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
    - 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员的析构函数是删除的或布克访问的，则类合成的拷贝函数也被定义为删除的
    - 如果类的某个成员的拷贝赋值运算符是删除的或布克访问的，或是类由一个 const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，他没有类内初始化器，或是类由一个 const 成员，他没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的
- 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
- private 拷贝控制
    - 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝


## 13.2 拷贝控制和资源管理
一般存在两种拷贝语义
- 可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针

### 13.2.1 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝
- 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针
- 定义一个析构函数来释放 string
- 定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝 string
```cpp
class HsaPtr {
    public:
        HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) {}
        HstPtr(const HasPtr &p): ps(new sdt::string(*p.ps)), i(p,i) {}
        HasPtr& operator=(const HsaPtr &);
        ~HasPtr() {delete ps;}
    private:
        std::string *ps;
        int i;
};
```

- 类值拷贝赋值运算符
    ```cpp
    HasPtr& HasPtr::operator=(const HasPtr &rhs){
        auto newp = new string(*rhs.ps);
        delete ps;
        ps = newp;
        i = rhs.i;
        return *this;
    }
    ```

- 赋值运算符
    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作，一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象

### 13.2.2 定义行为像指针的类
对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的 string  
希望直接管理资源时使用引用计数
- 引用计数
    - 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态，当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
    - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
    - 析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
    - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对下国内的计数器，如果左侧运算对象的计数器变为0，意味着他的共享状态没有用户了，拷贝赋值运算符就必须销毁状态
    - 将引用计数器保存在动态内存中，当创建一个对象时，我们也分配一个新的计数器，当拷贝或赋值对象时，我们拷贝指向计数器的指针，使用这种方法，副本和原对象都会指向相同的计数器
- 定义一个使用引用计数的类
    ```cpp
    class HasPtr{
        public:
            HasPtr(const std::string &s = std::string()): 
                ps(new std::string(s)), i(0), use(new std::size_t(1)) {}
            HasPtr(const HasPtr &p):
                ps(p.ps), i(p.i), use(p.use) { ++*use;}
            HasPtr& operator=(const HstPtr&);
            ~HasPtr();
        private:
            std::string *ps;
            int i;
            std::size_t *use;
    };
    ```
- 类指针的拷贝成员"篡改"引用计数
    - 析构函数应该递减引用函数，指出共享 string 的对象少了一个，如果计数器变为0，则析构函数释放 ps 和 use 指向的内存
    - 处理自赋值问题
        ```cpp
        HasPtr& HasPtr::operator=(const HasPtr &rhs){
            ++*rhs.use;
            if (--*use == 0){
                delete ps;
                delete use;
            }
            ps = rhs.ps;
            i = rhs.i;
            use = rhs.use;
            return *this;
        }
        ```

## 13.3 交换操作
除了定义拷贝控制成员，管理资源的类通常还定义一个名为 swap 的函数，对于与重排元素顺序的算法一起使用的类，会在交换两个原不俗时调用 swap  
如果一个类自定义了自己的 swap ，那么算法将使用类自定义版本
- 编写我们自己的 swap 函数
    ```cpp
    class HasPtr {
        friend void swap(HasPtr&, HasPtr&);
    };
    inline
    void swap(HasPtr &lhs, HsaPtr &rhs){
        using std::swap;
        swap(lhs.ps, rhs.ps);
        swap(lhs.i, rhs.i);
    }
    - 与拷贝控制成员不同，swap 并不是必要的，但是对于分配了资源的类，定义 swap 可能是一种很重要的优化手段
- swap 函数应该调用 swap，而不是 std::swap
- 在赋值运算符中使用 swap
    - 定义 swap 的类通常用 swap 来定义它们的赋值运算符，使用了一种名为拷贝并交换的计数
    ```cpp
    // rhs 按照值传递，意味着 HasPtr 的拷贝构造函数
    // 将右侧运算对象中的 string 拷贝到 rhs
    HasPtr& HasPtr::operator=(HasPtr rhs){
        // 交换左侧运算对象和局部变量rhs 的内容
        swap(*this,rhs); // rhs 现在指向本对象曾经使用的内存
        return *this; // rhs 被销毁，从而 delete 了 rhs 中的指针
    }
    ```
    - 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值

## 13.4 拷贝控制实例
拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作，这种情况下，公共的工作应该放在 private 的工具函数中完成
- message 类
- save 和 remove 成员
- message 类的拷贝控制成员
- message 的析构函数
- message 的拷贝赋值运算符
- message 的 swap 函数

## 13.5 动态内存管理类
某些类需要在运行时分配可变大小的内存空间，这种类通常可以使用标准库容器来保存他们的数据
- StrVec 类的设计
    - 每个 StrVec 有三个指针成员指向其元素所使用的内存
        - elements 指向分配的内存中的首元素
        - first_free 指向最后一个实际元素之后的位置
        - cap 指向分配的内存末尾之后的位置
    - alloc 静态成员 四个工具函数
        - alloc_n_copy 分配内存拷贝一个给定范围中的元素
        - free 销毁构造的元素并释放内存
        - chk_n_alloc 保证 StrVec 至少有容纳一个新元素的空间，如果没有添加新元素， chk_n_alloc 会调用 reallocate 来分配更多内存
        - reallocate 在内存用完时为 StrVec 分配新内存
- StrVec 类定义
- 使用 construct
    - 使用 allocator 分配内存时，内存是未构造的
- alloc_n_copy 成员
- free 成员
- 拷贝控制成员
- 在重新分配内存的过程中移动而不是拷贝元素
    - 拷贝后如果每个 string 只有唯一的用户，即可避免拷贝元素
- 移动构造函数和 std::move
    - 一些标准库定义了移动构造函数
    - move 标准库函数
        - 定义在 utility 头文件中
- reallocate 成员

## 13.6 对象移动
标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝，IO 类和 unique_ptr 类可以移动但不能拷贝

### 13.6.1 右值引用
必须绑定到右值的引用，通过 && 而不是 & 来引用  
只能绑定到一个将要销毁的对象，可以自由的将一个右值引用资源移动到另一个对象
- 返回左值的表达式
    - 返回左值医用的函数，连同赋值、下标、解引用和前置递增/递减运算符
- 返回右值的表达式
    - 返回非引用类型的函数，联通算数，关系，位以及后置递增/递减运算符
    - 不能将一个右值引用绑定到这类表达式上，但可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式