PART 3 类设计者的工具

# 13 拷贝控制
一个类通过定义五种特殊成员函数来控制操作
1. 拷贝构造函数
2. 拷贝赋值运算符
3. 自动构造函数
4. 移动赋值运算符
5. 析构函数

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数
```cpp
class Foo{
    public:
        Foo();
        Foo(const Foo&);
}
```
拷贝构造函数的第一个参数必须是一个引用类型
- 合成拷贝构造函数
    - 对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象
    - 一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中
        - 每个成员的类型决定了它如何拷贝
- 拷贝初始化
    - 在以下情况下也会发生
        - 将一个对象作为实参传递给一个非引用类型的形参
        - 从一个返回类型为非引用类型的函数返回一个对象
        - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
    - 使用标准库容器或是调用其 insert 或 push 成员时，容器会对其匀速进行拷贝初始化
    - 用 emplace 的成员创建的元素都进行直接初始化
- 参数和返回值
    - 拷贝构造函数被用来初始化非引用类类型参数
- 拷贝初始化的限制
- 编译器可以绕过拷贝构造函数
    - 在初始化工程中，编译器可以但不是必须跳过/移动构造函数，直接创建对象

### 13.1.2 拷贝赋值运算符
- 重载赋值运算符
    - 本质为函数，名字由 operator 关键字后接表示要定义的运算符的符号组成
    - 拷贝赋值运算符接受一个与其所在类相同类型的参数
    - 赋值运算符通常应该返回一个指向其左侧运算对象的引用
- 合成拷贝赋值运算符
    - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

### 13.1.3 析构函数
- 构造函数初始化对象的非 static 数据成员，还可能做一些其他工作
- 析构函数释放对象使用的资源，并销毁对象的非 static 数据成员
- 对一个给定类，只会有一个析构函数
- 析构函数完成什么工作
    - 首先执行函数体，然后销毁成员，成员按初始化的逆序销毁
    - 对象最后一次使用之后，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，西沟部分是隐式的，成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁呢之类型成员什么也不需要做
    - 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象
- 什么时候会调用析构函数
    - 无论何时一个对象被销毁，就会自动调用其析构函数
        - 变量在离开其作用域时被销毁
        - 当一个对象被销毁时，其成员被销毁
        - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
        - 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁
        - 对于临时对象，当创建它的完整表达式结束时被销毁
    - 当指向一个对象的引用或指针离开作用域时，析构函数不会执行
- 合成析构函数
    - 可以用来阻止该类型的对象被销毁
    - 析构函数是作为成员销毁步骤之外的另一部分而进行的


### 13.1.4 三/五法则
- 需要析构函数的类也需要拷贝和赋值操作
    - 通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显，如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
- 需要拷贝操作的类也需要赋值操作，反之亦然

### 13.1.5 使用 =default
可以通过将拷贝成员定义为 =default 来显式的要求编译器生成合成的版本
- 只能对具有合成版本的成员函数使用 = default

### 13.1.6 阻止拷贝
- 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地
- 定义删除的函数
    - 可以通过将拷贝构造函数和赋值运算符定义为删除的函数来阻止拷贝
    - 虽然声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上 =delete 来指出我们希望它定义为删除的
    - = default 必须出现在函数第一次声明的时候
    - 可以对任何函数指定 =delete
- 析构函数不能是删除的成员
    - 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针
- 合成的拷贝控制成员可能是删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
    - 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员的析构函数是删除的或布克访问的，则类合成的拷贝函数也被定义为删除的
    - 如果类的某个成员的拷贝赋值运算符是删除的或布克访问的，或是类由一个 const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，他没有类内初始化器，或是类由一个 const 成员，他没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的
- 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
- private 拷贝控制
    - 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝


## 13.2 拷贝控制和资源管理
一般存在两种拷贝语义
- 可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针

### 13.2.1 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝
- 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针
- 定义一个析构函数来释放 string
- 定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝 string
```cpp
class HsaPtr {
    public:
        HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) {}
        HstPtr(const HasPtr &p): ps(new sdt::string(*p.ps)), i(p,i) {}
        HasPtr& operator=(const HsaPtr &);
        ~HasPtr() {delete ps;}
    private:
        std::string *ps;
        int i;
};
```

- 类值拷贝赋值运算符
    ```cpp
    HasPtr& HasPtr::operator=(const HasPtr &rhs){
        auto newp = new string(*rhs.ps);
        delete ps;
        ps = newp;
        i = rhs.i;
        return *this;
    }
    ```

- 赋值运算符
    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作，一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象

### 13.2.2 定义行为像指针的类
对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的 string  
希望直接管理资源时使用引用计数
- 引用计数
    - 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态，当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
    - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
    - 析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
    - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对下国内的计数器，如果左侧运算对象的计数器变为0，意味着他的共享状态没有用户了，拷贝赋值运算符就必须销毁状态
    - 将引用计数器保存在动态内存中，当创建一个对象时，我们也分配一个新的计数器，当拷贝或赋值对象时，我们拷贝指向计数器的指针，使用这种方法，副本和原对象都会指向相同的计数器
- 定义一个使用引用计数的类
    ```cpp
    class HasPtr{
        public:
            HasPtr(const std::string &s = std::string()): 
                ps(new std::string(s)), i(0), use(new std::size_t(1)) {}
            HasPtr(const HasPtr &p):
                ps(p.ps), i(p.i), use(p.use) { ++*use;}
            HasPtr& operator=(const HstPtr&);
            ~HasPtr();
        private:
            std::string *ps;
            int i;
            std::size_t *use;
    };
    ```
- 类指针的拷贝成员"篡改"引用计数
    - 析构函数应该递减引用函数，指出共享 string 的对象少了一个，如果计数器变为0，则析构函数释放 ps 和 use 指向的内存
    - 处理自赋值问题
        ```cpp
        HasPtr& HasPtr::operator=(const HasPtr &rhs){
            ++*rhs.use;
            if (--*use == 0){
                delete ps;
                delete use;
            }
            ps = rhs.ps;
            i = rhs.i;
            use = rhs.use;
            return *this;
        }
        ```

## 13.3 交换操作
除了定义拷贝控制成员，管理资源的类通常还定义一个名为 swap 的函数，对于与重排元素顺序的算法一起使用的类，会在交换两个原不俗时调用 swap  
如果一个类自定义了自己的 swap ，那么算法将使用类自定义版本
- 编写我们自己的 swap 函数
    ```cpp
    class HasPtr {
        friend void swap(HasPtr&, HasPtr&);
    };
    inline
    void swap(HasPtr &lhs, HsaPtr &rhs){
        using std::swap;
        swap(lhs.ps, rhs.ps);
        swap(lhs.i, rhs.i);
    }
    - 与拷贝控制成员不同，swap 并不是必要的，但是对于分配了资源的类，定义 swap 可能是一种很重要的优化手段
- swap 函数应该调用 swap，而不是 std::swap
- 在赋值运算符中使用 swap
    - 定义 swap 的类通常用 swap 来定义它们的赋值运算符，使用了一种名为拷贝并交换的计数
    ```cpp
    // rhs 按照值传递，意味着 HasPtr 的拷贝构造函数
    // 将右侧运算对象中的 string 拷贝到 rhs
    HasPtr& HasPtr::operator=(HasPtr rhs){
        // 交换左侧运算对象和局部变量rhs 的内容
        swap(*this,rhs); // rhs 现在指向本对象曾经使用的内存
        return *this; // rhs 被销毁，从而 delete 了 rhs 中的指针
    }
    ```
    - 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值

## 13.4 拷贝控制实例
拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作，这种情况下，公共的工作应该放在 private 的工具函数中完成
- message 类
- save 和 remove 成员
- message 类的拷贝控制成员
- message 的析构函数
- message 的拷贝赋值运算符
- message 的 swap 函数

## 13.5 动态内存管理类
某些类需要在运行时分配可变大小的内存空间，这种类通常可以使用标准库容器来保存他们的数据
- StrVec 类的设计
    - 每个 StrVec 有三个指针成员指向其元素所使用的内存
        - elements 指向分配的内存中的首元素
        - first_free 指向最后一个实际元素之后的位置
        - cap 指向分配的内存末尾之后的位置
    - alloc 静态成员 四个工具函数
        - alloc_n_copy 分配内存拷贝一个给定范围中的元素
        - free 销毁构造的元素并释放内存
        - chk_n_alloc 保证 StrVec 至少有容纳一个新元素的空间，如果没有添加新元素， chk_n_alloc 会调用 reallocate 来分配更多内存
        - reallocate 在内存用完时为 StrVec 分配新内存
- StrVec 类定义
- 使用 construct
    - 使用 allocator 分配内存时，内存是未构造的
- alloc_n_copy 成员
- free 成员
- 拷贝控制成员
- 在重新分配内存的过程中移动而不是拷贝元素
    - 拷贝后如果每个 string 只有唯一的用户，即可避免拷贝元素
- 移动构造函数和 std::move
    - 一些标准库定义了移动构造函数
    - move 标准库函数
        - 定义在 utility 头文件中
- reallocate 成员

## 13.6 对象移动
标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝，IO 类和 unique_ptr 类可以移动但不能拷贝

### 13.6.1 右值引用
必须绑定到右值的引用，通过 && 而不是 & 来引用  
只能绑定到一个将要销毁的对象，可以自由的将一个右值引用资源移动到另一个对象
- 返回左值的表达式
    - 返回左值医用的函数，连同赋值、下标、解引用和前置递增/递减运算符
- 返回右值的表达式
    - 返回非引用类型的函数，联通算数，关系，位以及后置递增/递减运算符
    - 不能将一个右值引用绑定到这类表达式上，但可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式
- 左值持久；右值短暂
    - 左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的临时对象
    - 右值引用只能绑定到临时的对象即
        - 所引用的对象将要被销毁
        - 该对象没有其他用户
    - 使用右值引用的代码可以自由的接管所引用的对象的资源
    - 右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象窃取状态
- 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行
- 标准库 move 函数
    - 可以显使的将一个左值转换为对应的右值引用类型
    - 调用 move 函数来获得绑定到左值上的右值引用
        eg `int &&rr3 = std::move(rr1);`
    - 在调用 move 后，不能对移后源对象的值做任何假设
    - 可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值
    - 使用 move 不提供 using 声明，直接嗲用 `std::move` 而不是 move

### 13.6.2 移动构造函数和移动赋值运算符
为了让自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符  
```cpp
StrVec::StrVec(StrVec &&s) noexcept : elements(s.elements), first_free(s.first_free), cap(s.cap) {
    s.elements = s.first_free = s.cap = nullptr;
}
```
noexcept 通知标准库我们的构造函数不抛出任何一场
- 移动操作、标准库容器和异常
    - noexcept 承诺不会抛出异常
    - 必须在类头文件的声明和定义(如果定义在类外的话)中都指定 noexcept
    - 不抛出异常的移动构造函数和移动赋值运算符必须标记为 noexcept
    - 避免在移动过程中出现错误导致数据异常，若未声明不会抛出异常，就会使用拷贝构造函数而不是移动构造函数
- 移动赋值运算符
    ```cpp
    StrVec &StrVec::operator=(StrVec &&rhs) noexcept{
        if(this != &rhs){
            free();
            elements = rhs.elements;
            first_free = rhs.first_free;
            cap = rhs.cap;
            rhs.elements = rhs.first_free = rhs.cap = nullptr;
        }
        return *this
    }
    ```
    - 需要能处理自赋值
    - 不能再使用右侧运算对象的资源之前就释放左侧运算对象的资源
- 移后源对象必须可析构
    - 当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态
    - 在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其=值进行任何假设
- 合成移动操作
    - 编译器不会为某些类合成移动操作
    - 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符
    - 移动操作永远不会隐式定义为删除的函数
    - 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除的
- 移动右值，拷贝左值
    - 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数
- 如果没有移动构造函数，右值也被拷贝
    - 如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用 move 来移动也是如此
- 拷贝并交换赋值运算符和移动操作
    ```cpp
    class HasPtr{
    public:
        //添加的移动构造函数
        HasPtr(HasPtr &&p) noexcept : ps(p.ps),i(p.i) {p.ps = 0;}
        //赋值运算符既是移动赋值运算符，也是拷贝赋值运算符
        HasPtr& operator=(HasPtr rhs) {
            swap(*this, rhs); return *this;
        };
    }
    ```
- Message 类的移动操作
    - 移动赋值运算符必须销毁左侧运算对象的旧状态
- 移动迭代器
    - 一个移动迭代器通过改变给定迭代器的解引用运算符行为来适配次迭代器
    - 一般来说一个迭代器的解引用运算符返回一个指向元素的左值，而移动迭代器解引用运算符生成一个右值引用
    - 通过调用标准库的 make_move_iterator 函数将一个普通迭代器其转换为一个移动迭代器
    - 原迭代器的所有操作在移动迭代器中都照常工作
    - 特别的，可以将移动爹大气传递给 uninitialized_copy

### 13.6.3 右值引用和成员函数
区分移动和拷贝的重载函数通常有一个版本接受一个 const T&，而另一个版本接受一个 T&&
- 右值和左值引用成员函数
    - 强制左侧运算对象是一个左值，在参数列表后放置一个引用限定符
    - 引用限定符可以是 & 或 &&，分别指出 this 可以指向一个左值或右值
    - 只能用于非 static 成员函数，且必须同时出现在函数的声明和定义中
    - 对于 & 限定的函数只能用于左值
    - 对于 && 限定的函数只能用于右值
    - 一个函数可以同时用 const 和引用限定，引用限定符跟随在 const 限定符之后
- 重载和引用函数
    - 引用限定符也可以区分重载版本
    - 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符


# 14 重载运算与类型转换

## 14.1 基本概念
重载的运算符是具有特殊名字的函数: 它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体  
除了重载函数的调用运算符 operator() 之外，其他重载运算符不饿能含有默认参数  
当一个重载的运算符是成员函数时，this 绑定到左侧运算对象。成员运算符函数的显式参数数量比运算对象的数量少一个  
对于一个运算符函数来说，它或者是类的成员或者至少含有一个类类型的参数  
只能重载已有的运算符，无权发明新的运算符
不可以被重载的运算符  (:: .* . ?:)
- 直接调用一个重载的运算符函数
    - 通常情况下，我们将运算符作用域类型正确的实参，从而以这种间接方式调用重载运算符函数
        ```cpp
        data1 + data2;
        operator+(data1, data2);
        ```
- 某些运算符不应该被重载
    - 某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，这些关于运算对象求值顺序的规则无法应用到重载的运算符上
        -  特别的，逻辑与运算符、逻辑或运算符和逗号运算符的运算求值顺序规则无法保留
        -  && 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值
        -  通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符
- 使用与内置类型一致的含义
    - 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
    - 如果类的某个操作是检查相等性，则定义 operator==; 如果类有了 operator==，意味着它通常也应该有 operator!=
    - 如果类包含一个内在的单序比较操作，则定义 operator<; 如果类有了 operator<, 则它应该含有其他关系操作
    - 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容: 逻辑运算符和关系u你算符应该返回 bool, 算数运算符应该返回 bool，算数运算符应该返回一个类类型的值，赋值运算符和符合赋值运算符则应该返回运算对象的一个引用
- 赋值和复合赋值运算符
    - 赋值之后，左侧运算对象和右侧运算对象的值相等，并且于是运算符应该返回它左侧运算对象的一个引用
    - 如果类含有算数运算符或者位运算符，则最好也提供对应的赋值运算符
- 选择作为成员或者非成员
    - 当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数
    - 抉择定义为成员函数还是普通的非成员函数
        - 赋值(=)、下标、调用和成员访问箭头运算符必须是成员
        - 符合赋值运算符一般来说成员，但并非必须，这一点与赋值运算符略有不同
        - 改变对象状态的运算符或者与给定类型密切相关的u你算符，如递增、递减和解引用运算符，通常应该是成员
        - 具有对称性的运算符可能转换任意一端的运算对象，例如算数、相等性、关系和位运算符等，因此它们通常应该是一些普通的非成员函数


## 14.2 输入和输出运算符

### 14.2.1 重载输出运算符 <<
通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用，之所以 ostream 时非常量是因为流写入内容会改变其状态  
第二个形参是一个常量的引用
- 输出运算符尽量减少格式化操作
    - 令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节
    - 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符
- 输入输出运算符必须是非成员函数
    - 与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数，否则它的左侧运算对象将是我们的类的一个对象

### 14.2.2 重载输入运算符 >>
通常情况下第一个形参使运算符将要读取的流的引用  
第二个形参是将要读入到(非常量)对象的引用  
输入运算符必须处理输入可能失败的情况，而输出运算符不需要
- 输入时的错误
    - 可能发生的错误
        - 当流含有错误类型的数据时读取操作可能失败
        - 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败
    - 当读取操作发生错误时，输入运算符应该负责从错误中恢复
- 标识错误

## 14.3 算数和关系运算符
通常情况下，把算数运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换  
如果同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符

### 14.3.1 相等运算符
设计准则
- 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 operator== 而非一个普通的命名函数
- 如果类定义了 operator== ，则该运算符应该能判断一组给定对象中是否含有重复数据
- 通常情况下，相等运算符应该具有传递性
- 如果类定义了 operator==，则这个类也应该定义 operator!= 
- 相等运算符和不相等运算符中的一个应该把工作委托给另一个
- 如果某个类在逻辑上有相等性的含义，则该类应该定义 operator==，这样做可以使得用户过呢更容易使用标准库算法来处理这个类
  
### 14.3.2 关系运算符
通常情况下关系运算符应该
1. 定义顺序关系，令其与关联容器中对关键字的要求一致
2. 如果类同时也含有 == 运算符的话，则定义一种关系令其与 == 保持一致，特别是，如果两个对象是 != 的，那么一个对象应该 < 另一个

如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符，如果类同时还包含 == ，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符 


## 14.4 赋值运算符
类也可以定义其他赋值运算符以使用别的类型作为右侧运算对象  
为了与内置类型的运算符保持一致，这个新的赋值运算符将返回其左侧运算对象的引用  
可以重载赋值运算符，不论形参的类型时什么，赋值运算符都必须定义为成员函数
- 复合赋值运算符
    - 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用

## 14.5 下标运算符
定义下标运算符 operator[]  
下标运算符必须是成员函数  
如果一个类包含下标运算符，则它通常会定义两个版本: 一个返回普通引用，另一个是类的常量成员并且返回常量引用

## 14.6 递增和递减运算符
定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员
- 定义前置递增/递减运算符
    - 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用
- 区分前置和后置运算符
    - 后置版本接受一个额外的(不被使用)int 类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参
    - 为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用
    - 对于后置版本，在递增对象之前需要首先记录对象的状态
    - 不会用到 int 形参，所以无须为其命名
- 显式地调用后置运算符
    ```cpp
    StrBlobPtr p(a1);
    p.operator++(0); //调用后置版本的 operator++
    p.operator++(); //调用前置版本的 operator++
    ```

## 14.7 成员访问运算符
箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管非必须如此
- 对箭头运算符返回值的限定
    - 当我们重载箭头时，可以改变的是箭头从哪个对象中获取成员，而箭头获取成员这一事实则永远不变
- point-> mem 的执行过程
    - 如果 point 是指针，则我们应用内置的箭头运算符，表达式等价于(*point).mem
    - 如果 point 是定义了 operator-> 的类的一个对象，则我们使用 point.operator->()的结果来获取 mem
- 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象


## 14.8 调用函数运算符
函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符 ，相互之间应该在参数数量或类型上有所区别  
如果类定义了调用运算符，则该类的对象称作函数对象，因为可以调用这种对象，所以我们说这些类的行为像函数一样  
- 含有状态的函数对象类
    - 和其他类一样，函数对象类除了 operator() 之外也可以包含其他成员，函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作
    - 这两个形参的默认实参分别是 cout 和空格，只有的调用运算符使用这些成员协助其打印给定的 string
    - 函数对象常常作为泛型算法的实参


### 14.8.1 lambda 是函数对象
当我们编写一个 lambda 后，编译器将该表达式翻译成一个未命名对象，在 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象，在 lambda 表达式产生的类中含有一个重载的函数调用运算符  
因此在默认情况下，由 lambda 产生的类当中的调用运算符是一个 const 成员函数  
用这个类替代 lambda 表达式后，我们可以重写并重新调用 stable_sort
- 表示 lambda 及相应捕获行为的类
    - lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定

### 14.8.2 标准库定义的函数对象
functional 头文件
||||
|---|---|---|
|**算数**|**关系**|**逻辑**|
|plus<Type>|equal_to<Type>|logical_and<Type>|
|minus<Type>|not_equal_to<Type>|logical<Type>|
|multiplies<Type>|greater<Type>|logical<Type>|
|divides<Type>|greater_equal<Type>||
|modulus<Type>|less<Type>||
|negate<Type>|less_equal<Type>||

- 在算法中使用标准库函数对象
    - 表示运算符的函数对象类常用来替换算法中的运算符
    - greater 类型的对象将产生一个调用运算符并负责执行待排序类型的大于运算
    - 也可以作用于指针

### 14.8.3 可调用对象于 function
函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符  
两个不同类型的可调用对象却可能共享同一种调用形式  
调用形式指明了返回的类型
- 不同类型可能具有相同的调用形式
    - 定义一个函数表用于存储指向这些可调用对象的指针，当程序需要执行某个特定的操作时从表中查找该调用函数
- 标准库 function 操作
    1. function<T> f;  f是一个用来存储可调用对象的空 function ，这些可调用对象的调用形式应该与函数类型 T 相同
    2. function<T> f(nullptr); 显式地构造一个空 function
    3. function<T> f(obj); 在 f 中存储可调用对象 obj 地副本
    4. f 将 f 作为条件: 当 f 含有一个可调用对象时为真；否则为假
    5. f(args) 调用 f 中对象，参数是 args
- 定义为 function<T> 的成员的类型
    1. result_type 该 function 类型的可调用对象返回的类型
    2. argument_type 
        first_argument_type 
        second_argumnet_type
        当 T 由一个或连个实参时定义的类型，如果 T 只有一个实参，则 argument_type 是该类型的同义词: 如果 T 有两个实参，则 first_argument_type 和 second_argument_type 分别代表两个实参的类型
- 调用形式  `function<int(int, int)>`
- 重载的函数与 function
    - 不能直接将重载函数的名字存入 function 类型的对象中
    - 通过存储函数指针而非函数名字 或使用 lambda 消除二义性

## 14.9 重载、类型转换与运算符
转换构造函数和类型转换运算符共同定义了类类型转换，这样的转换有时也被称作用户定义的类型转换  

### 14.9.1 类型转换运算符
类型转换运算符是类的一种特殊成员函数 ，负责将一个类类型的值转换成其他类型  
`operator type() const;`
类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。  
- 一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是 const
- 定义含有类型转换运算符的类
    - 尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准(内置)类型转换之前或之后
    - 因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就可能在类型转换运算符的定义中使用任何形参
- 类型转换运算符可能产生意外结果
    - 大多数情况类型转换自动发生
- 显式的类型转换运算符
    - 当表达式出现在下列位置时，显式的类型转换将被隐式的执行
        - if、while 及 do 语句的条件部分
        - for 语句头的条件表达式
        - 逻辑非运算符(!)、逻辑或运算符(||)、逻辑与运算符(&&)的运算对象
        - 条件运算符(?:)的条件表达式
- 转换为 bool
    - IO 标准库通过定义一个向 bool 的显式类型转换实现同样的目的
    - 向 bool 的类型准换通常用在条件部分，因此 operator bool 一般定义成 explicit 的

### 14.9.2 避免有二义性的类型转换
两种情况下可能产生多重转换路径
1. 两个类提供相同的类型转换
2. 类定义了多个转换规则
通常情况下，不要为类定义相同的类型转换，也不要再类中定义两个及两个以上转换源或准换目标是算术类型的转换
- 实参匹配和相同的类型转换
    - 如果确实想要执行上述调用，就不得不显式地调用类型转换运算符或者转换构造函数
- 二义性与转换目标为内置类型的多重类型转换
    - 定义了一组类型转换，他们的转换源类型本身可以通过其他类型中转换联系在一起，则同样会产生二义性问题
    - 党委偶们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个
- 重载函数与构造转换函数
    - 如果在调用重载函数时我们需要构造函数或者强制类型转换类改变实参的类型，则这通常意味着程序的设计存在不足
- 重载函数与用户定义的类型转换
    - 当调用重载函数时，如果两个用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好，在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别
    - 调用重载函数时，如果需要额外的类型转换，则该转换的界别只有当所有可行函数都请求同一个用户定义的类型转换时才有用，如果所需的用户定义的类型转换不止一个，则该调用具有二义性

### 14.9.3 函数匹配与重载运算符
当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本，除此之外如果左侧于是暖对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数中
- 表达式中运算符的候选函数集既应该包含成员函数，也应该包含非成员函数
- 如果我们对同一个类既提供类转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题


# 15 面向对象程序设计

## 15.1 OOP: 概述
面向对象程序设计的核心思想是数据抽象、继承和动态绑定
- 继承
    - 通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类
    - 基类负责定义在层次关系中所有类共同拥有地成员，而每个派生类定义各自特有地成员
    - 基类将类型相关地函数与派生类不做改变直接继承地函数区分对待，对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明称虚函数
    - 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的
        - 冒号后跟逗号分隔的基类列表，其中基类前面可以有访问说明符
        - 允许派生类显式地注明它将使用哪个成员函数改写基类地虚函数，在该函数地形参列表之后增加一个 override 关键字
- 动态绑定
    - 使用动态绑定，能用同一段代码分别处理 Quote 和 Bulk_quote 对象
    - 函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被陈伟运行时绑定
    - 当使用基类的引用(或指针)调用一个虚函数时将发生动态绑定

## 15.2 定义基类和派生类

### 15.2.1 定义基类
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此
- 成员函数与继承
    - 派生类可以继承其基类的成员，需要对这些操作提供自己的新定义以覆盖从基类继承而来的旧定义
    - 基类的两种成员
        - 基类希望其派生类进行覆盖的函数
            - 通常定义为虚函数，使用指针或引用调用时，将被同台绑定
        - 基类希望派生类直接继承而不要改变的函数
    - 任何构造函数之外的非静态函数都可以是虚函数
- 访问控制与继承
    - 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员
    - 使用受保护的访问运算符说明基类希望它的派生类有权访问但禁止其他用户访问的成员

### 15.2.2 定义派生类
派生类必须通过实用类派生列表明确指出它是从哪个(哪些)基类继承而来的  
类派生列表的形式是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以又以下三种访问说明符中的一个
- public
- protected
- private

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明  
访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见  
如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分，我们能将公有派生类型的对象绑定到基类的引用或指针上

- 派生类中的虚函数
    - 派生类经常（但不总是）覆盖它继承的虚函数，
    - 如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为欸死于其他的普通成员，派生类会直接继承其在基类中的版本
    - C++ 11 允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数
        - 在形参列表之后，或者 const 成员函数，引用成员函数的引用限定符后添加关键字 override
- 派生类对象及派生类向基类的类型转换
    - 派生类对象组成部分
        - 含有派生类自己定义的非静态成员的子对象
        - 一个与该派生类继承的基类对应的子对象
        - 因为派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上
    - 转换通常称为派生类到基类的类型转换，编译器会隐式地执行派生类到基类地转换
    - 在派生类对象中含有与其基类对应地组成部分
- 派生类构造函数
    - 派生类也必须使用类地构造函数来初始化它地基类部分
    - 每个类控制它自己的成员初始化过程
    - 除非指出，否则派生类会像数据成员一样执行默认初始化，
    - 如果想使用其他的基类构造函数，需要以类名加圆括号的实参列表的形式为构造函数提供初始值
    - 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员
- 派生类使用基类的成员
    - 派生类可以访问基类的公有成员和受保护成员
    - 派生类的做由于嵌套在基类的作用域中
- 继承与静态成员
    - 如果基类定义类一个静态成员，则在整个继承体系中只存在该成员的唯一定义。无论基类派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例
- 派生类的声明
    - 声明中包含类名但是不包含它的派生列表
        ```cpp
        class Buld_quote : public Quote; // 错误
        class Buld_quote; // 正确
        ```
- 被用作基类的类
    - 如果想将某个类用作基类，则该类必须已经定义而非仅仅声明
    - 一个类不能派生它自己
    - 可以派生派生类，直接基类，间接基类
    - 最终的派生类将包含他的直接积累的子对象和每个间接基类的子对象
- 防止继承的发生
    - 在类名后跟一个关键字 `final` 防止继承的发生


### 15.2.3 类型转换与继承
存在继承关系的类是一个例外，
可以将积累的指针或引用绑定到派生类对象上  
当使用基类的引用或指针时，实际上我们并不清楚该引用或指针所绑定对象的真实类型  
与内置指针一样，智能指针类也支持派生类向基类的类型转换，可以将一个派生类对象的指针存储在一个基类的智能指针中
- 静态类型与动态类型
    - 当存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来
    - 静态类型在编译时总是已知的，动态类型则是变量或表达式的内存中的对象的类型，直到运行时才可知
    - 基类的指针或引用的动态类型可能与其动态类型不一致
- 不存在基类向派生类的隐式转换
    - 如哦已知某个基类向派生类的转换是安全的，则可以使用 static_cast 来强制覆盖掉编译器的检查工作
- 在对象之间不存在的类型转换
    - 派生类向基类的自动转换只对指针或引用类有效，在派生类类型和基类类型之间不存在这样的转换
    - 当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉
  
## 15.3
- 对虚函数的调用可能在运行时才被解析
    - 当某个虚函数通过指针或引用调用时，编译器产生的代码知道运行时才能确定应该调用哪个版本的函数，被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个
    - 动态绑定只有当我们通过指针或调用虚函数时才会发生
- 派生类中的虚函数
    - 当我们在派生类中覆盖了某个虚函数时，可以再一次使用 virtual 关键字指出该函数的性质
    - 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致
    - 派生类中虚函数的返回类型也必须与基类函数匹配，当类的虚函数返回类型是类本身的指针或引用时，该规则无效
    - 基类中的虚函数再派生类中隐含地也是一个虚函数，当派生类覆盖了某个虚函数时，该函数再基类中地形参必须与派生类中的形参严格匹配
- final 和 override 说明符
    - 派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然合法，编译器将认为新定义的这个函数与基类中原有的函数是相互独立的
    - C++ 11 新标准中可以使用 override 关键字来说明派生类中的虚函数
    - 将函数定义成 final 或任何尝试覆盖该函数的操作都将引发错误
    - final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置返回类型之后
- 虚函数与默认实参
    - 如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此
    - 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致
- 回避虚函数的机制
    - 在某些情况下，希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，使用作用域运算符实现
        ```cpp
        double undiscounted = baseP -> Quote::net_price(42);
        // 强行调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么
        ```
    - 通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的极值
    - 当一个派生类的虚函数调用它覆盖的基类的虚函数版本是，需要回避虚函数的调用机制
    - 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则再运行时掉哦那个将被解析为对派生类版本自身的调用，从而导致无限递归

## 15.4 抽象基类
- 纯虚函数
    - 将函数定义成纯虚函数从而令用户知道该函数没有实际意义
    - 纯虚函数无须定义，通过在函数体的位置书写 =0 就可以将一个虚函数说明为纯虚函数
    - 可以为纯虚函数提供定义，不过函数体必须定义在类的外部，也就是说，不能再类的内部为一个 =0 的函数提供函数体
- 含有纯虚数的类是抽象基类
    - 含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类
    - 抽象基类负责定义接口，而后续的其他类可以覆盖该接口
    - 不能创建抽象基类的对象
- 派生类构造函数只初始化它的直接基类

## 15.5 访问控制与继承
每个类分别控制着其成员对于派生类来说是否可访问
- 受保护的成员
    - 一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员
        - 和私有成员类似，收保护的成员对于类的用户来说是不可访问的
        - 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的
        - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权
    - 派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类成员不具有特殊的访问权限
- 公有、私有和受保护继承
    - 某个类对其继承而来的访问权限受到两个因素影响
        - 在基类中该成员的访问说明符
        - 派生类的派生列表中的访问声明符
    - 派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响
    - 对基类成员的访问全写只与基类中的访问说明符有关
    - 访问说明符还可以集成自派生类的新类的访问权限
- 派生类向基类转换的可访问性
    - 派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响，假定 D 继承自 B
        - 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类地转换
        - 不论 D 以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说是永远可以访问的
        - 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之则不能
    - 对于代码中的某个给定节点来说，如果积累的公有成员是可访问的，则派生类向基类转换也是可访问的，反之则不行
- 友元与继承
    - 友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员
    - 不能继承友元关系；每个类负责控制各自成员的访问权限
- 改变个别成员的可访问性
    - 通过 using 声明可以改变派生类继承的某个名字的访问级别
    - 通过在类的内部使用 using 声明语句，可以将该类的直接或间接基类中的任何可访问成员标记出来
    - using 声明语句中名字的访问权限由该 using 声明语句之前的访问说明符来决定
    - 派生类只能为那些它可以访问的名字提供 using 声明
- 默认的继承保护级别
    - 在使用 struct 关键字和 class 关键字定义的类之间还由更深层次的差别—— 默认成员
    - 一个私有派生的类最好显式的将 private 声明出来，而不要仅仅依赖于默认的设置，显式声明的好处是可以令私有继承关系清晰明了

## 15.6 继承中的类作用域
- 每个类定义自己的作用域，在这个作用域内定义类的成员，当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内
- 如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义
- 在编译时进行名字查找
    - 一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型与动态类型可能不一致，但能使用哪些成员仍然是由静态类型决定的
- 名字冲突与继承
    - 派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将定义在外层作用域（即基类）的名字
    - 派生类的成员将隐藏同名的基类成员
- 通过作用域运算符来使用隐藏的成员
    - 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字
- 一如往常，名字查找先于类型检查
    - 声明在内层作用域的函数并不会重载生命在外层作用域的函数，定义在派生类中的函数也不会重载其基类中成员
    - 如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员，即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉
    - 一旦查找到对应名字，编译器就不再继续查找了
- 虚函数与作用域
    - 派生类中的虚函数必须有相同的形参列表
- 通过基类调用隐藏的虚函数
    - 通过基类的指针进行调用，编译器产生的代码将在运行时确定使用虚函数的哪个版本，判断依据是该指针所绑定对象的真实类型
- 覆盖重载的函数
    - 成员函数无论是否是虚函数都能被重载，派生类可以覆盖重载函数的 0 个或多个实例，如果派生类希望所有的重载版本对于它来说都是可见的，那么就需要覆盖所有版本，或者一个也不覆盖
    - 为重载的成员提供一条 using 声明语句，无须覆盖基类中的每一个重载版本

## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数
在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本
只要基类的析构函数是虚函数，就能确保delete 基类指针时将运行正确的析构函数版本
如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生未定义的行为
```cpp
class Quote {
public:
    virtual ~Quote() = default;
};
Quote *itemP = new Quote;
delete itemP; //调用 quote 析构函数
itemP = new Buld_quote;
delete itemP; //调用 Bulk_quote 析构函数
```
- 虚析构函数将阻止合成移动操作
    - 基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的ing想；如果一个类定义了虚析构函数，即使通过 = default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作

### 15.7.2 合成拷贝控制与继承
- 基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似
    - 对类本身的成员依次进行初始化、赋值或销毁操作
- 派生类隐式地使用而基类通过将其虚析构函数定义成 =default 而显式地使用
- 对于派生类地析构函数来说，除了销毁派生类自己的成员之外，还负责销毁派生类的直接积累，该直接基类又销毁它自己的直接基类，以此类推至继承链的顶端
- 派生类中删除的拷贝控制与基类的关系 
    - 基类或派生类也能将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数
    - 某些定义基类的方式也可能导致有的派生类成员被定义成被删除的函数
        - 如果基类中的默认构造函数、拷贝复制运算符或析构函数是被删除的函数或者不可访问，则派生类中合成的默认和拷贝构造函数将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作
        - 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是删除的，因为编译器无法销毁派生类对象的基类部分
        - 和过去一样，编译器将不会合成一个删除掉的移动操作，当我们使用 =default 请求一个移动操作时，原因是派生类对象的基类部分不可移动
- 移动操作与继承
    - 大多数基类会定义一个虚析构函数，积累通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作
    - 基类缺少移动操作会阻止派生类拥有自己的合成移动操作，需要执行移动操作时应该首先在基类中进行定义
    ```cpp
    class Quote {
    public:
        Quote() = default; //对成员依次进行默认初始化
        Quote(const Quote&) = default; //对成员依次拷贝
        Quote(Quote&&) = default; //对成员依次拷贝
        Quote& operator = (const Quote&) = default; //拷贝赋值
        Quote& operator = (Quote&&) = default; //移动操作
        virtual ~Quote() = default;
    };

### 15.7.3 派生类的拷贝控制成员
派生类的构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分  
派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值  
当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象  
- 定义派生类的拷贝或移动构造函数
    - 当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分
    - 在默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果我们向拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显式地使用积累的拷贝或移动构造函数
- 派生类赋值运算符
    - 派生类地赋值运算符也必须显式地为其基类部分赋值
    - 无论基类地构造函数或赋值运算符是自定义地版本还是合成的版本，派生类地对应操作都能使用它们
- 派生类地析构函数
    - 析构函数体执行完成后，对象地成员会被隐式销毁，对象的基类部分也是隐式销毁的
    - 派生类析构函数只负责销毁由派生类自己分配的资源
    - 对象销毁地顺序与创建的顺序相反，派生类析构函数首先执行，然后是积累的析构函数，以此类推，沿着继承体系地反方向直至最后
- 在构造函数和析构函数中调用虚函数
    - 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本

### 15.7.4 继承的构造函数
C++ 11 中派生类能够重用其直接基类定义的构造函数  
一个类只初始化它的直接基类  
一个类也只继承其直接积累的构造函数  
派生类继承基类构造函数的方式是提供一条注明了基类名的 using 声明语句  
通常情况下，using 声明语句只是令某个名字在当前作用域内可见，而当作用于构造函数时，using 声明语句将令编译器产生代码  
对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数
编译器生成的构造函数形如
`derived(parms) : base(args) { }`
derived 是派生类的名字， base 是基类的名字， parms 是构造函数的形参列表， args 将派生类构造函数的形参传递给基类的构造函数
- 继承的构造函数的特点
    - 一个构造函数的 using 声明不会改变该构造函数的访问级别
    - 当一个基类构造函数含有默认实参时，这些实参并不会被继承
    - 派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参
    - 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承，定义在派生类中的构造函数将替换继承而来的构造函数

## 15.8 容器与继承
当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式，因为不允许在容器中保存不同类型的元素，不能把具有继承关系的多种类型的对象直接存放在容器中  
当派生类对象被赋值给基类对象时，其中的派生类部分将被切掉，因此容器和存在继承关系的类型无法兼容  
- 在容器中放置智能指针而非对象
    - 但我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）

### 15.8.1 编写 Basket 类
定义一个 compare 的私有静态成员，该成员负责比较 shared_ptr 所指的对象的 isbn
```cpp
std::multiset<std::shared_ptr<Quote>, decltype(compare)*> items{compare};
```
- 定义 Basket 的成员
    - 在类的内部定义的 add_item 成员，接受一个指向动态分配的 Quote 的 shared_ptr 然后将这个 shared_ptr 放置在 multiset 中
    - 第二个成员的名字是 total_receipt，它负责将购物篮的内容逐项打印成清单
- 隐藏指针
    - Basket 的用户仍然必须处理动态内存
        ```cpp
        void add_item(const Quote& sale); //拷贝给定的对象
        void add_item(Quote&& sale); //移动给定的对象
        ```
- 模拟虚拷贝
    - 为了解决上述问题，给 Quote 类添加一个虚函数，该函数将申请一份当前对象的拷贝
        ```cpp
        class Quote {
        public:
            virtual Quote* clone() cosnt & {return new Quote(*this);}
            virtual Quote* clone() && {return new Quote(std::move(*this));}
        };
        class Bulk_quote : public Quote {
            Bulk_quote* clone() const & {return new Bulk_quote(*this);}
            Bulk_quote* clone() && {return new Bulk_quote(std::move(*this));}
        };
        ```