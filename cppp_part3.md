PART 3 类设计者的工具

# 13 拷贝控制
一个类通过定义五种特殊成员函数来控制操作
1. 拷贝构造函数
2. 拷贝赋值运算符
3. 自动构造函数
4. 移动赋值运算符
5. 析构函数

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数
```cpp
class Foo{
    public:
        Foo();
        Foo(const Foo&);
}
```
拷贝构造函数的第一个参数必须是一个引用类型
- 合成拷贝构造函数
    - 对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象
    - 一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中
        - 每个成员的类型决定了它如何拷贝
- 拷贝初始化
    - 在以下情况下也会发生
        - 将一个对象作为实参传递给一个非引用类型的形参
        - 从一个返回类型为非引用类型的函数返回一个对象
        - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
    - 使用标准库容器或是调用其 insert 或 push 成员时，容器会对其匀速进行拷贝初始化
    - 用 emplace 的成员创建的元素都进行直接初始化
- 参数和返回值
    - 拷贝构造函数被用来初始化非引用类类型参数
- 拷贝初始化的限制
- 编译器可以绕过拷贝构造函数
    - 在初始化工程中，编译器可以但不是必须跳过/移动构造函数，直接创建对象

### 13.1.2 拷贝赋值运算符
- 重载赋值运算符
    - 本质为函数，名字由 operator 关键字后接表示要定义的运算符的符号组成
    - 拷贝赋值运算符接受一个与其所在类相同类型的参数
    - 赋值运算符通常应该返回一个指向其左侧运算对象的引用
- 合成拷贝赋值运算符
    - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

### 13.1.3 析构函数
- 构造函数初始化对象的非 static 数据成员，还可能做一些其他工作
- 析构函数释放对象使用的资源，并销毁对象的非 static 数据成员
- 对一个给定类，只会有一个析构函数
- 析构函数完成什么工作
    - 首先执行函数体，然后销毁成员，成员按初始化的逆序销毁
    - 对象最后一次使用之后，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，西沟部分是隐式的，成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁呢之类型成员什么也不需要做
    - 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象
- 什么时候会调用析构函数
    - 无论何时一个对象被销毁，就会自动调用其析构函数
        - 变量在离开其作用域时被销毁
        - 当一个对象被销毁时，其成员被销毁
        - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
        - 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁
        - 对于临时对象，当创建它的完整表达式结束时被销毁
    - 当指向一个对象的引用或指针离开作用域时，析构函数不会执行
- 合成析构函数
    - 可以用来阻止该类型的对象被销毁
    - 析构函数是作为成员销毁步骤之外的另一部分而进行的


### 13.1.4 三/五法则
- 需要析构函数的类也需要拷贝和赋值操作
    - 通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显，如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
- 需要拷贝操作的类也需要赋值操作，反之亦然

### 13.1.5 使用 =default
可以通过将拷贝成员定义为 =default 来显式的要求编译器生成合成的版本
- 只能对具有合成版本的成员函数使用 = default

### 13.1.6 阻止拷贝
- 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地
- 定义删除的函数
    - 可以通过将拷贝构造函数和赋值运算符定义为删除的函数来阻止拷贝
    - 虽然声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上 =delete 来指出我们希望它定义为删除的
    - = default 必须出现在函数第一次声明的时候
    - 可以对任何函数指定 =delete
- 析构函数不能是删除的成员
    - 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针
- 合成的拷贝控制成员可能是删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
    - 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员的析构函数是删除的或布克访问的，则类合成的拷贝函数也被定义为删除的
    - 如果类的某个成员的拷贝赋值运算符是删除的或布克访问的，或是类由一个 const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，他没有类内初始化器，或是类由一个 const 成员，他没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的
- 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
- private 拷贝控制
    - 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝


## 13.2 拷贝控制和资源管理
一般存在两种拷贝语义
- 可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针

### 13.2.1 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝
- 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针
- 定义一个析构函数来释放 string
- 定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝 string
```cpp
class HsaPtr {
    public:
        HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) {}
        HstPtr(const HasPtr &p): ps(new sdt::string(*p.ps)), i(p,i) {}
        HasPtr& operator=(const HsaPtr &);
        ~HasPtr() {delete ps;}
    private:
        std::string *ps;
        int i;
};
```

- 类值拷贝赋值运算符
    ```cpp
    HasPtr& HasPtr::operator=(const HasPtr &rhs){
        auto newp = new string(*rhs.ps);
        delete ps;
        ps = newp;
        i = rhs.i;
        return *this;
    }
    ```

- 赋值运算符
    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作，一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象

### 13.2.2 定义行为像指针的类
对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的 string  
希望直接管理资源时使用引用计数
- 引用计数
    - 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态，当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
    - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
    - 析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
    - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对下国内的计数器，如果左侧运算对象的计数器变为0，意味着他的共享状态没有用户了，拷贝赋值运算符就必须销毁状态
    - 将引用计数器保存在动态内存中，当创建一个对象时，我们也分配一个新的计数器，当拷贝或赋值对象时，我们拷贝指向计数器的指针，使用这种方法，副本和原对象都会指向相同的计数器
- 定义一个使用引用计数的类
    ```cpp
    class HasPtr{
        public:
            HasPtr(const std::string &s = std::string()): 
                ps(new std::string(s)), i(0), use(new std::size_t(1)) {}
            HasPtr(const HasPtr &p):
                ps(p.ps), i(p.i), use(p.use) { ++*use;}
            HasPtr& operator=(const HstPtr&);
            ~HasPtr();
        private:
            std::string *ps;
            int i;
            std::size_t *use;
    };
    ```
- 类指针的拷贝成员"篡改"引用计数
    - 析构函数应该递减引用函数，指出共享 string 的对象少了一个，如果计数器变为0，则析构函数释放 ps 和 use 指向的内存
    - 处理自赋值问题
        ```cpp
        HasPtr& HasPtr::operator=(const HasPtr &rhs){
            ++*rhs.use;
            if (--*use == 0){
                delete ps;
                delete use;
            }
            ps = rhs.ps;
            i = rhs.i;
            use = rhs.use;
            return *this;
        }
        ```

## 13.3 交换操作
除了定义拷贝控制成员，管理资源的类通常还定义一个名为 swap 的函数，对于与重排元素顺序的算法一起使用的类，会在交换两个原不俗时调用 swap  
如果一个类自定义了自己的 swap ，那么算法将使用类自定义版本
- 编写我们自己的 swap 函数
    ```cpp
    class HasPtr {
        friend void swap(HasPtr&, HasPtr&);
    };
    inline
    void swap(HasPtr &lhs, HsaPtr &rhs){
        using std::swap;
        swap(lhs.ps, rhs.ps);
        swap(lhs.i, rhs.i);
    }
    - 与拷贝控制成员不同，swap 并不是必要的，但是对于分配了资源的类，定义 swap 可能是一种很重要的优化手段
- swap 函数应该调用 swap，而不是 std::swap
- 在赋值运算符中使用 swap
    - 定义 swap 的类通常用 swap 来定义它们的赋值运算符，使用了一种名为拷贝并交换的计数
    ```cpp
    // rhs 按照值传递，意味着 HasPtr 的拷贝构造函数
    // 将右侧运算对象中的 string 拷贝到 rhs
    HasPtr& HasPtr::operator=(HasPtr rhs){
        // 交换左侧运算对象和局部变量rhs 的内容
        swap(*this,rhs); // rhs 现在指向本对象曾经使用的内存
        return *this; // rhs 被销毁，从而 delete 了 rhs 中的指针
    }
    ```
    - 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值

## 13.4 拷贝控制实例
拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作，这种情况下，公共的工作应该放在 private 的工具函数中完成
- message 类
- save 和 remove 成员
- message 类的拷贝控制成员
- message 的析构函数
- message 的拷贝赋值运算符
- message 的 swap 函数

## 13.5 动态内存管理类
某些类需要在运行时分配可变大小的内存空间，这种类通常可以使用标准库容器来保存他们的数据
- StrVec 类的设计
    - 每个 StrVec 有三个指针成员指向其元素所使用的内存
        - elements 指向分配的内存中的首元素
        - first_free 指向最后一个实际元素之后的位置
        - cap 指向分配的内存末尾之后的位置
    - alloc 静态成员 四个工具函数
        - alloc_n_copy 分配内存拷贝一个给定范围中的元素
        - free 销毁构造的元素并释放内存
        - chk_n_alloc 保证 StrVec 至少有容纳一个新元素的空间，如果没有添加新元素， chk_n_alloc 会调用 reallocate 来分配更多内存
        - reallocate 在内存用完时为 StrVec 分配新内存
- StrVec 类定义
- 使用 construct
    - 使用 allocator 分配内存时，内存是未构造的
- alloc_n_copy 成员
- free 成员
- 拷贝控制成员
- 在重新分配内存的过程中移动而不是拷贝元素
    - 拷贝后如果每个 string 只有唯一的用户，即可避免拷贝元素
- 移动构造函数和 std::move
    - 一些标准库定义了移动构造函数
    - move 标准库函数
        - 定义在 utility 头文件中
- reallocate 成员

## 13.6 对象移动
标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝，IO 类和 unique_ptr 类可以移动但不能拷贝

### 13.6.1 右值引用
必须绑定到右值的引用，通过 && 而不是 & 来引用  
只能绑定到一个将要销毁的对象，可以自由的将一个右值引用资源移动到另一个对象
- 返回左值的表达式
    - 返回左值医用的函数，连同赋值、下标、解引用和前置递增/递减运算符
- 返回右值的表达式
    - 返回非引用类型的函数，联通算数，关系，位以及后置递增/递减运算符
    - 不能将一个右值引用绑定到这类表达式上，但可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式
- 左值持久；右值短暂
    - 左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的临时对象
    - 右值引用只能绑定到临时的对象即
        - 所引用的对象将要被销毁
        - 该对象没有其他用户
    - 使用右值引用的代码可以自由的接管所引用的对象的资源
    - 右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象窃取状态
- 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行
- 标准库 move 函数
    - 可以显使的将一个左值转换为对应的右值引用类型
    - 调用 move 函数来获得绑定到左值上的右值引用
        eg `int &&rr3 = std::move(rr1);`
    - 在调用 move 后，不能对移后源对象的值做任何假设
    - 可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值
    - 使用 move 不提供 using 声明，直接嗲用 `std::move` 而不是 move

### 13.6.2 移动构造函数和移动赋值运算符
为了让自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符  
```cpp
StrVec::StrVec(StrVec &&s) noexcept : elements(s.elements), first_free(s.first_free), cap(s.cap) {
    s.elements = s.first_free = s.cap = nullptr;
}
```
noexcept 通知标准库我们的构造函数不抛出任何一场
- 移动操作、标准库容器和异常
    - noexcept 承诺不会抛出异常
    - 必须在类头文件的声明和定义(如果定义在类外的话)中都指定 noexcept
    - 不抛出异常的移动构造函数和移动赋值运算符必须标记为 noexcept
    - 避免在移动过程中出现错误导致数据异常，若未声明不会抛出异常，就会使用拷贝构造函数而不是移动构造函数
- 移动赋值运算符
    ```cpp
    StrVec &StrVec::operator=(StrVec &&rhs) noexcept{
        if(this != &rhs){
            free();
            elements = rhs.elements;
            first_free = rhs.first_free;
            cap = rhs.cap;
            rhs.elements = rhs.first_free = rhs.cap = nullptr;
        }
        return *this
    }
    ```
    - 需要能处理自赋值
    - 不能再使用右侧运算对象的资源之前就释放左侧运算对象的资源
- 移后源对象必须可析构
    - 当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态
    - 在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其=值进行任何假设
- 合成移动操作
    - 编译器不会为某些类合成移动操作
    - 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符
    - 移动操作永远不会隐式定义为删除的函数
    - 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除的
- 移动右值，拷贝左值
    - 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数
- 如果没有移动构造函数，右值也被拷贝
    - 如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用 move 来移动也是如此
- 拷贝并交换赋值运算符和移动操作
    ```cpp
    class HasPtr{
    public:
        //添加的移动构造函数
        HasPtr(HasPtr &&p) noexcept : ps(p.ps),i(p.i) {p.ps = 0;}
        //赋值运算符既是移动赋值运算符，也是拷贝赋值运算符
        HasPtr& operator=(HasPtr rhs) {
            swap(*this, rhs); return *this;
        };
    }
    ```
- Message 类的移动操作
    - 移动赋值运算符必须销毁左侧运算对象的旧状态
- 移动迭代器
    - 一个移动迭代器通过改变给定迭代器的解引用运算符行为来适配次迭代器
    - 一般来说一个迭代器的解引用运算符返回一个指向元素的左值，而移动迭代器解引用运算符生成一个右值引用
    - 通过调用标准库的 make_move_iterator 函数将一个普通迭代器其转换为一个移动迭代器
    - 原迭代器的所有操作在移动迭代器中都照常工作
    - 特别的，可以将移动爹大气传递给 uninitialized_copy

### 13.6.3 右值引用和成员函数
区分移动和拷贝的重载函数通常有一个版本接受一个 const T&，而另一个版本接受一个 T&&
- 右值和左值引用成员函数
    - 强制左侧运算对象是一个左值，在参数列表后放置一个引用限定符
    - 引用限定符可以是 & 或 &&，分别指出 this 可以指向一个左值或右值
    - 只能用于非 static 成员函数，且必须同时出现在函数的声明和定义中
    - 对于 & 限定的函数只能用于左值
    - 对于 && 限定的函数只能用于右值
    - 一个函数可以同时用 const 和引用限定，引用限定符跟随在 const 限定符之后
- 重载和引用函数
    - 引用限定符也可以区分重载版本
    - 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符


# 14 重载运算与类型转换

## 14.1 基本概念
重载的运算符是具有特殊名字的函数: 它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体  
除了重载函数的调用运算符 operator() 之外，其他重载运算符不饿能含有默认参数  
当一个重载的运算符是成员函数时，this 绑定到左侧运算对象。成员运算符函数的显式参数数量比运算对象的数量少一个  
对于一个运算符函数来说，它或者是类的成员或者至少含有一个类类型的参数  
只能重载已有的运算符，无权发明新的运算符
不可以被重载的运算符  (:: .* . ?:)
- 直接调用一个重载的运算符函数
    - 通常情况下，我们将运算符作用域类型正确的实参，从而以这种间接方式调用重载运算符函数
        ```cpp
        data1 + data2;
        operator+(data1, data2);
        ```
- 某些运算符不应该被重载
    - 某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，这些关于运算对象求值顺序的规则无法应用到重载的运算符上
        -  特别的，逻辑与运算符、逻辑或运算符和逗号运算符的运算求值顺序规则无法保留
        -  && 和 || 运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值
        -  通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符
- 使用与内置类型一致的含义
    - 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
    - 如果类的某个操作是检查相等性，则定义 operator==; 如果类有了 operator==，意味着它通常也应该有 operator!=
    - 如果类包含一个内在的单序比较操作，则定义 operator<; 如果类有了 operator<, 则它应该含有其他关系操作
    - 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容: 逻辑运算符和关系u你算符应该返回 bool, 算数运算符应该返回 bool，算数运算符应该返回一个类类型的值，赋值运算符和符合赋值运算符则应该返回运算对象的一个引用
- 赋值和复合赋值运算符
    - 赋值之后，左侧运算对象和右侧运算对象的值相等，并且于是运算符应该返回它左侧运算对象的一个引用
    - 如果类含有算数运算符或者位运算符，则最好也提供对应的赋值运算符
- 选择作为成员或者非成员
    - 当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数
    - 抉择定义为成员函数还是普通的非成员函数
        - 赋值(=)、下标、调用和成员访问箭头运算符必须是成员
        - 符合赋值运算符一般来说成员，但并非必须，这一点与赋值运算符略有不同
        - 改变对象状态的运算符或者与给定类型密切相关的u你算符，如递增、递减和解引用运算符，通常应该是成员
        - 具有对称性的运算符可能转换任意一端的运算对象，例如算数、相等性、关系和位运算符等，因此它们通常应该是一些普通的非成员函数


## 14.2 输入和输出运算符

### 14.2.1 重载输出运算符 <<
通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用，之所以 ostream 时非常量是因为流写入内容会改变其状态  
第二个形参是一个常量的引用
- 输出运算符尽量减少格式化操作
    - 令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节
    - 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符
- 输入输出运算符必须是非成员函数
    - 与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数，否则它的左侧运算对象将是我们的类的一个对象

### 14.2.2 重载输入运算符 >>
通常情况下第一个形参使运算符将要读取的流的引用  
第二个形参是将要读入到(非常量)对象的引用  
输入运算符必须处理输入可能失败的情况，而输出运算符不需要
- 输入时的错误
    - 可能发生的错误
        - 当流含有错误类型的数据时读取操作可能失败
        - 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败
    - 当读取操作发生错误时，输入运算符应该负责从错误中恢复
- 标识错误

## 14.3 算数和关系运算符
通常情况下，把算数运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换  
如果同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符

### 14.3.1 相等运算符
设计准则
- 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 operator== 而非一个普通的命名函数
- 如果类定义了 operator== ，则该运算符应该能判断一组给定对象中是否含有重复数据
- 通常情况下，相等运算符应该具有传递性
- 如果类定义了 operator==，则这个类也应该定义 operator!= 
- 相等运算符和不相等运算符中的一个应该把工作委托给另一个
- 如果某个类在逻辑上有相等性的含义，则该类应该定义 operator==，这样做可以使得用户过呢更容易使用标准库算法来处理这个类
  
### 14.3.2 关系运算符
通常情况下关系运算符应该
1. 定义顺序关系，令其与关联容器中对关键字的要求一致
2. 如果类同时也含有 == 运算符的话，则定义一种关系令其与 == 保持一致，特别是，如果两个对象是 != 的，那么一个对象应该 < 另一个

如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符，如果类同时还包含 == ，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符 


## 14.4 赋值运算符
类也可以定义其他赋值运算符以使用别的类型作为右侧运算对象  
为了与内置类型的运算符保持一致，这个新的赋值运算符将返回其左侧运算对象的引用  
可以重载赋值运算符，不论形参的类型时什么，赋值运算符都必须定义为成员函数
- 复合赋值运算符
    - 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用

## 14.5 下标运算符
定义下标运算符 operator[]  
下标运算符必须是成员函数  
如果一个类包含下标运算符，则它通常会定义两个版本: 一个返回普通引用，另一个是类的常量成员并且返回常量引用

## 14.6 递增和递减运算符
定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员
- 定义前置递增/递减运算符
    - 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用
- 区分前置和后置运算符
    - 后置版本接受一个额外的(不被使用)int 类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参
    - 为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用
    - 对于后置版本，在递增对象之前需要首先记录对象的状态
    - 不会用到 int 形参，所以无须为其命名
- 显式地调用后置运算符
    ```cpp
    StrBlobPtr p(a1);
    p.operator++(0); //调用后置版本的 operator++
    p.operator++(); //调用前置版本的 operator++
    ```

## 14.7 成员访问运算符
箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管非必须如此
- 对箭头运算符返回值的限定
    - 当我们重载箭头时，可以改变的是箭头从哪个对象中获取成员，而箭头获取成员这一事实则永远不变
- point-> mem 的执行过程
    - 如果 point 是指针，则我们应用内置的箭头运算符，表达式等价于(*point).mem
    - 如果 point 是定义了 operator-> 的类的一个对象，则我们使用 point.operator->()的结果来获取 mem
- 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象