PART 3 类设计者的工具

# 13 拷贝控制
一个类通过定义五种特殊成员函数来控制操作
1. 拷贝构造函数
2. 拷贝赋值运算符
3. 自动构造函数
4. 移动赋值运算符
5. 析构函数

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数
```cpp
class Foo{
    public:
        Foo();
        Foo(const Foo&);
}
```
拷贝构造函数的第一个参数必须是一个引用类型
- 合成拷贝构造函数
    - 对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象
    - 一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中
        - 每个成员的类型决定了它如何拷贝
- 拷贝初始化
    - 在以下情况下也会发生
        - 将一个对象作为实参传递给一个非引用类型的形参
        - 从一个返回类型为非引用类型的函数返回一个对象
        - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
    - 使用标准库容器或是调用其 insert 或 push 成员时，容器会对其匀速进行拷贝初始化
    - 用 emplace 的成员创建的元素都进行直接初始化
- 参数和返回值
    - 拷贝构造函数被用来初始化非引用类类型参数
- 拷贝初始化的限制
- 编译器可以绕过拷贝构造函数
    - 在初始化工程中，编译器可以但不是必须跳过/移动构造函数，直接创建对象

### 13.1.2 拷贝赋值运算符
- 重载赋值运算符
    - 本质为函数，名字由 operator 关键字后接表示要定义的运算符的符号组成
    - 拷贝赋值运算符接受一个与其所在类相同类型的参数
    - 赋值运算符通常应该返回一个指向其左侧运算对象的引用
- 合成拷贝赋值运算符
    - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

### 13.1.3 析构函数
- 构造函数初始化对象的非 static 数据成员，还可能做一些其他工作
- 析构函数释放对象使用的资源，并销毁对象的非 static 数据成员
- 对一个给定类，只会有一个析构函数
- 析构函数完成什么工作
    - 首先执行函数体，然后销毁成员，成员按初始化的逆序销毁
    - 对象最后一次使用之后，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，西沟部分是隐式的，成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁呢之类型成员什么也不需要做
    - 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象
- 什么时候会调用析构函数
    - 无论何时一个对象被销毁，就会自动调用其析构函数
        - 变量在离开其作用域时被销毁
        - 当一个对象被销毁时，其成员被销毁
        - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
        - 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁
        - 对于临时对象，当创建它的完整表达式结束时被销毁
    - 当指向一个对象的引用或指针离开作用域时，析构函数不会执行
- 合成析构函数
    - 可以用来阻止该类型的对象被销毁
    - 析构函数是作为成员销毁步骤之外的另一部分而进行的


### 13.1.4 三/五法则
- 需要析构函数的类也需要拷贝和赋值操作
    - 通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显，如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
- 需要拷贝操作的类也需要赋值操作，反之亦然

### 13.1.5 使用 =default
可以通过将拷贝成员定义为 =default 来显式的要求编译器生成合成的版本
- 只能对具有合成版本的成员函数使用 = default

### 13.1.6 阻止拷贝
- 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地
- 定义删除的函数
    - 可以通过将拷贝构造函数和赋值运算符定义为删除的函数来阻止拷贝
    - 虽然声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上 =delete 来指出我们希望它定义为删除的
    - = default 必须出现在函数第一次声明的时候
    - 可以对任何函数指定 =delete
- 析构函数不能是删除的成员
    - 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针
- 合成的拷贝控制成员可能是删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
    - 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员的析构函数是删除的或布克访问的，则类合成的拷贝函数也被定义为删除的
    - 如果类的某个成员的拷贝赋值运算符是删除的或布克访问的，或是类由一个 const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
    - 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，他没有类内初始化器，或是类由一个 const 成员，他没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的
- 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
- private 拷贝控制
    - 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝


## 13.2 拷贝控制和资源管理
一般存在两种拷贝语义
- 可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针

### 13.2.1 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝
- 定义一个拷贝构造函数，完成 string 的拷贝，而不是拷贝指针
- 定义一个析构函数来释放 string
- 定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝 string
```cpp
class HsaPtr {
    public:
        HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) {}
        HstPtr(const HasPtr &p): ps(new sdt::string(*p.ps)), i(p,i) {}
        HasPtr& operator=(const HsaPtr &);
        ~HasPtr() {delete ps;}
    private:
        std::string *ps;
        int i;
};
```

- 类值拷贝赋值运算符
    ```cpp
    HasPtr& HasPtr::operator=(const HasPtr &rhs){
        auto newp = new string(*rhs.ps);
        delete ps;
        ps = newp;
        i = rhs.i;
        return *this;
    }
    ```

- 赋值运算符
    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作，一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象
